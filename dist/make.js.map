{"version":3,"file":"make.js","sourceRoot":"","sources":["../src/make.ts"],"names":[],"mappings":"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","sourcesContent":["import { given } from \"@nivinjoseph/n-defensive\";\n\n// public\nexport abstract class Make // static class\n{\n    private constructor() { }\n\n\n    public static retry<T>(func: (...params: any[]) => Promise<T>, numberOfRetries: number, errorPredicate?: (err: Error) => boolean): (...params: any[]) => Promise<T>\n    {\n        given(func, \"func\").ensureHasValue().ensureIsFunction();\n        given(numberOfRetries, \"numberOfRetries\").ensureHasValue().ensureIsNumber().ensure(t => t > 0);\n        given(errorPredicate, \"errorPredicate\").ensureIsFunction();\n        \n        let numberOfAttempts = numberOfRetries + 1;\n        \n        let result = async function (...p: any[]): Promise<T>\n        {\n            let successful = false;\n            let attempts = 0;\n\n            let funcResult: any;\n            let error: any;\n\n            while (successful === false && attempts < numberOfAttempts)\n            {\n                attempts++;\n\n                try \n                {\n                    funcResult = await func(...p);\n                    successful = true;\n                }\n                catch (err)\n                {\n                    error = err;\n                    if (errorPredicate && !errorPredicate(error))\n                        break;\n                }\n            }\n\n            if (successful)\n                return funcResult;\n\n            throw error;\n        };\n\n        return result;\n    }\n\n    public static retryWithDelay<T>(func: (...params: any[]) => Promise<T>, numberOfRetries: number, delayMS: number, errorPredicate?: (err: Error) => boolean): (...params: any[]) => Promise<T>\n    {\n        given(func, \"func\").ensureHasValue().ensureIsFunction();\n        given(numberOfRetries, \"numberOfRetries\").ensureHasValue().ensureIsNumber().ensure(t => t > 0);\n        given(errorPredicate, \"errorPredicate\").ensureIsFunction();\n        \n        let numberOfAttempts = numberOfRetries + 1;\n        \n        let result = async function (...p: any[]): Promise<T>\n        {\n            let successful = false;\n            let attempts = 0;\n\n            let funcResult: any;\n            let error: any;\n\n            let executeWithDelay = (delay: number) =>\n            {\n                return new Promise((resolve, reject) =>\n                {\n                    setTimeout(() =>\n                    {\n                        func(...p)\n                            .then(t => resolve(t))\n                            .catch(err => reject(err));\n                    }, delay);\n                });\n\n            };\n\n            while (successful === false && attempts < numberOfAttempts)\n            {\n                attempts++;\n\n                try \n                {\n                    funcResult = await executeWithDelay(attempts === 1 ? 0 : delayMS);\n                    successful = true;\n                }\n                catch (err)\n                {\n                    error = err;\n                    if (errorPredicate && !errorPredicate(error))\n                        break;\n                }\n            }\n\n            if (successful)\n                return funcResult;\n\n            throw error;\n        };\n\n        return result;\n    }\n\n    public static retryWithExponentialBackoff<T>(func: (...params: any[]) => Promise<T>, numberOfRetries: number, errorPredicate?: (err: Error) => boolean): (...params: any[]) => Promise<T>\n    {\n        given(func, \"func\").ensureHasValue().ensureIsFunction();\n        given(numberOfRetries, \"numberOfRetries\").ensureHasValue().ensureIsNumber().ensure(t => t > 0);\n        given(errorPredicate, \"errorPredicate\").ensureIsFunction();\n        \n        let numberOfAttempts = numberOfRetries + 1;\n        \n        let result = async function (...p: any[]): Promise<T>\n        {\n            let successful = false;\n            let attempts = 0;\n            let delayMS = 0;\n\n            let funcResult: any;\n            let error: any;\n\n            let executeWithDelay = (delay: number) =>\n            {\n                return new Promise((resolve, reject) =>\n                {\n                    setTimeout(() =>\n                    {\n                        func(...p)\n                            .then(t => resolve(t))\n                            .catch(err => reject(err));\n                    }, delay);\n                });\n\n            };\n\n            while (successful === false && attempts < numberOfAttempts)\n            {\n                attempts++;\n\n                try \n                {\n                    funcResult = await executeWithDelay(delayMS);\n                    successful = true;\n                }\n                catch (err)\n                {\n                    error = err;\n                    if (errorPredicate && !errorPredicate(error))\n                        break;\n                    delayMS = (delayMS + Make.getRandomInt(200, 500)) * attempts;\n                }\n            }\n\n            if (successful)\n                return funcResult;\n\n            throw error;\n        };\n\n        return result;\n    }\n    \n    public static syncToAsync<T>(func: (...params: any[]) => T): (...params: any[]) => Promise<T>\n    {\n        let result = function (...p: any[]): Promise<T>\n        {\n            try \n            {\n                let val = func(...p);\n                return Promise.resolve(val);\n            }\n            catch (error)\n            {\n                return Promise.reject(error);\n            }\n        };\n        \n        return result;\n    }\n    \n    public static callbackToPromise<T>(func: (...params: any[]) => void): (...params: any[]) => Promise<T>\n    {\n        let result = function (...p: any[]): Promise<T>\n        {\n            let promise = new Promise<any>((resolve, reject) =>\n                func(...p, (err: Error, ...values: any[]) =>\n                    err\n                        ? reject(err)\n                        : values.length === 0\n                            ? resolve()\n                            : values.length === 1\n                                ? resolve(values[0])\n                                : resolve(values)));\n            \n            return promise;\n        };   \n        \n        return result;\n    }\n\n    \n    private static getRandomInt(min: number, max: number): number\n    {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min)) + min; // The maximum is exclusive and the minimum is inclusive\n    }\n}"]}